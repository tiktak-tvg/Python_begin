# python_formatting
## Форматирование в Python с помощью format()
Строковый метод format() форматирует строки python для более красивого вывода.
Синтаксис метода:
<pre>
template.format(p0, p1, ..., k0=v0, k1=v1, ...)
Здесь p0, p1,... — это позиционные аргументы, а k0, k1,... — аргументы-ключевые
слова со значениями v0, v1,... соответственно.
А template — это набор строк с заполнителями для аргументов.
</pre>  
#### Параметры format()
Метод format() принимает любое количество параметров. Но они делятся на два вида:

- Позиционные аргументы — список параметров, доступ к которым можно получить по
индексу параметра в фигурных скобках {индекс}.
- Параметры — ключевые слова — список параметров типа ключ=значение, доступ к
которым можно получить с помощью ключа параметра в фигурных скобках {ключ}.
#### Возвращаемое значение format()
Метода format() возвращает отформатированную строку.<br>
#### Как работает format()?
Формат читает тип переданных аргументов и форматирует строку в соответствии с
кодами форматирования в строке.<br>
#### Для позиционных аргументов

![image](https://github.com/tvgVita69/python_formatting/assets/98489171/4aa1faa3-908b-4bd1-96ad-4edf86bdab4f)

Здесь Аргумент 0 — это строка “Adam”, а Аргумент 1 — число с плавающей точкой
230.2346.<br>
Список аргументов в Python начинается с 0.<br>
Строка Hello {0}, your balance is {1:9.3f} — это шаблон строки. Он содержит коды
форматирования.<br>
Фигурные скобки — это всего лишь заполнители, которые будут заменены аргументами. <br>
В примере выше {0} — это заполнитель для "Adam" , а {1:9.3f} — для 230.2346 . <br>
Поскольку шаблон строки ссылается на аргументы format() ({0} и {1}), они являются
позиционными аргумента. <br>На них можно ссылаться без использования чисел, а Python
конвертирует {} в числа автоматически.<br>
Что происходит:

Поскольку "Adam" — это нулевой аргумент, он располагается в позиции {0}. Поскольку
{0} не содержит других кодов форматирования, дополнительные операции не
осуществляются.<br>
Но в случае с первым аргументом, 230.2346 , ситуация
другая.<br> {1:9.3f} размещает 230.2346 на нужно месте и выполняет операцию 9.3f .
f определяет, что это формат числа с плавающей точкой. Если указать неправильно,
будет ошибка.<br>
Часть до точки (9) определяет минимальную ширину, которую может занимать число
230.2346. <br>В этом случае числу 230.2346 выделены 9 мест с точкой.<br>
Если параметр выравнивания не указан, то он выравнивается вправо до оставшихся
позиций (для строк — влево).<br>
Часть после точки (3) урезает десятичную часть (2346) до указанной числа. <br>В этом
случае 2346 может занимать три места. Остаток (46) округляется и выходит 235.<br>
#### Для аргументов-ключевых слов
![image](https://github.com/tvgVita69/python_formatting/assets/98489171/45cfaa29-dd93-4877-9423-b059ceab61f4)

В этом примере используется то же выражение, чтобы продемонстрировать разницу в
использовании позиционных и аргументов-ключевых слов.<br>
Здесь вместо просто параметров использованы сочетания ключ-значение. <br>А
именно: name="Adam" и blc=230.2346 .<br>
Поскольку ссылка на эти параметры происходит через ключи ( {name} и {blc:9.3f} ) —
это именованные аргументы.<br>
Что происходит внутри:

Заполнитель {name} заменяется значением ключа name — “Adam”. Никаких
дополнительных операций здесь нет.<br>
В случае с аргументом blc=230.2346 заполнитель {blc:9.3f} заменяется на
значение 230.2346 .<br> Но перед заменой производится операция 9.3f .<br>
Вывод — “230.235”. Десятичная часть обрезается после трех позиций, а оставшиеся
цифры округляются. Общая ширина — 9, а два символа остаются справа.<br>
#### Базовое форматирование с format()
Метод format() позволяет использовать простые заполнители для форматирования.<br>
**Пример №1**: базовое форматирование для аргументов по умолчанию,
позиционных и аргументов-ключевых слов.<br>
#аргументы по умолчанию<br>
print("Hello {}, your balance is {}.".format("Adam", 230.2346))<br>
#позиционные аргументы<br>
print("Hello {0}, your balance is {1}.".format("Adam", 230.2346))<br>
#аргументы ключевые слова<br>
print("Hello {name}, your balance is {blc}.".format(name="Adam", blc=230.2346)<br>)
#смешанные аргументы<br>
print("Hello {0}, your balance is {blc}.".format("Adam", blc=230.2346))<br>
При запуске программы вывод будет одинаковым:
<pre>
Hello Adam, your balance is 230.2346.
Hello Adam, your balance is 230.2346.
Hello Adam, your balance is 230.2346.
Hello Adam, your balance is 230.2346.
</pre>  
При использовании смешанных аргументов аргументы-ключевые слова
должны идти после позиционных аргументов.<br>
#### Форматирование чисел с format()
С помощью спецификаторов формата можно форматировать и числа:<br>
#### Типы форматирования чисел
<pre>
Тип Значение
d Десятичное число
c Соответствующий символ Unicode
b Двоичный формат
o Восьмеричный формат
x Шестнадцатеричный формат (в нижнем регистре)
X Шестнадцатеричный формат (в верхнем регистре)
n То же, что и d , но использует местную настройку для разделения числа
e Экспоненциальная запись (e в нижнем регистре)
E Экспоненциальная запись (E в верхнем регистре)
f Отображать фиксированное количество знаков (по умолчанию 6)
F То же, что и f , только отображает inf как INF , а nan как NAN
g Общий формат. Округляет число до p значащих цифр (Точность по умолчанию: 6)
G То же, что и g . Но переключается к E , если число очень большое
% Проценты. Делит на 100 и добавляет % в конце
</pre>  
**Пример №2**: простое форматирование чисел.<br>
#целочисленные аргументы<br>
print("The number is:{:d}".format(123))<br>
#аргументы с плавающей точкой<br>
print("The float number is:{:f}".format(123.4567898))<br>
#восьмеричный, двоичный и шестнадцатеричный формат<br>
print("bin: {0:b}, oct: {0:o}, hex: {0:x}".format(12))<br><br>
При запуске этой программы вывод будет следующий:
<pre>
The number is: 123
The number is:123.456790
bin: 1100, oct: 14, hex: c
</pre>  
**Пример №3**: форматирование чисел с полями для целых и чисел с
плавающей точкой.<br>
#целые числа с минимальной шириной<br>
print("{:5d}".format(12))<br>
#ширина не работает для чисел длиннее заполнения<br>
print("{:2d}".format(1234))<br>
#заполнение для чисел с плавающей точкой<br>
print("{:8.3f}".format(12.2346))<br>
#целые числа с минимальной шириной, заполненные нулями<br>
print("{:05d}".format(12))<br>
#заполнение для чисел с плавающей запятой, заполненных нулями<br>
print("{:08.3f}".format(12.2346))<br>
Эта программа выдаст следующее:
<pre>
12
1234
12.235
00012
0012.235
</pre>  
Здесь:

В первой инструкции {:5d} принимает целое число в качестве аргумента и задает
минимальную ширину 5. Поскольку настройка выравнивания не задана, оно
выравнивается к правому краю.<br>
Во втором ширина (2) меньше, чем размер числа (1234), поэтому слева не появляется
свободное пространство, но число и не обрезается.<br>
В отличие от целых чисел у чисел с плавающей точкой есть целая и десятичная части.
Минимальная ширина в этом случае включает обе из них и точку.<br>
В третьем выражении {:8.3f} обрезает десятичную часть, округляя ее до 2 цифр. И
число, теперь 12.235, занимает 8 позиций, оставляя 2 пустых местах слева.<br>
Если нужно заполнить оставшиеся места нулями, спецификатор может сделать и это. Это
работает как для целых чисел, так и для чисел с плавающей
точкой: {:05d} и {:08.3f} .<br>
**Пример №4**: форматирование чисел со знаками.<br>
#показать знак +<br>
print("{:+f} {:+f}".format(12.23, -12.23))<br>
#показать знак -<br>
print("{:-f} {:-f}".format(12.23, -12.23))<br>
#показать место для знака +<br>
print("{: f} {: f}".format(12.23, -12.23))<br>
Вывод будет следующий:
<pre>
+12.230000 -12.230000
12.230000 -12.230000
12.230000 -12.230000
</pre>  
#### Форматирование чисел с выравниванием
Операторы < , ^ , > и = используются для выравнивания в том случае, если указана
конкретная ширина.<br>
Форматирование чисел с выравниванием
<pre>
Тип Значение
< Выравнивается по левому краю
^ Выравнивается по центру
> Выравнивается по правому краю
= Сдвигает знаки (+ или -) к левой позиции
</pre>  
**Пример №5**: форматирование чисел с выравниванием по центру,
левому и правому краю.<br>
#целые числа с выравниванием по правому краю<br>
print("{:5d}".format(12))<br>
#числа с плавающей точкой с выравниванием по центру<br>
print("{:^10.3f}".format(12.2346))<br>
#выравнивание целого числа по левому краю заполнено нулями<br>
print("{:<05d}".format(12))<br>
#числа с плавающей точкой с выравниванием по центру<br>
print("{:=8.3f}".format(-12.2346))<br>
Вывод этой программы:
<pre>
12
12.235
12000
- 12.235
</pre> 
<br>
Выравнивание по левому краю с нулями для целых чисел может создать
проблемы, как в случае с третьим примером, который возвращает 12000
вместо 12.<br>
####Форматирование строк с format()
Как и числа, строки можно форматировать с помощью format().

**Пример №6**: форматирование строк с полями и выравниванием.<br>
#отступ строки с выравниванием по левому краю<br>
print("{:5}".format("cat"))<br>
#отступ строки с выравниванием по правому краю<br>
print("{:>5}".format("cat"))<br>
#заполнение строк с выравниванием по центру<br>
print("{:^5}".format("cat"))<br>
#заполнение строк с выравниванием по центру<br>
#и '*' - символ заполнения<br>
print("{:*^5}".format("cat"))<br>
При запуске программы вывод будет следующим:
<pre>
cat
cat
cat
*cat*
</pre>

**Пример №7**: обрезание строк.<br>
#обрезание строк до 3 букв<br>
print("{:.3}.".format("caterpillar"))<br>
#обрезание строк до 3 букв и заполнение<br>
print("{:5.3}.".format("caterpillar"))<br>
#обрезание строк до 3 букв,
#заполнение и выравнивание по центру<br>
print("{:^5.3}.".format("caterpillar"))<br>

Вывод будет следующим:
<pre>
cat.
cat .
cat .
</pre>  
#### Форматирование элементов классов и словарей с format()
Python использует getattr() для элементов класса в форме “.age”. А __getitem__() —
для элементов словаря в форме “[index]”.<br>
**Пример №8**: форматирование элементов класса с format().<br>
#определяем класс Person<br>
class Person:<br>
age = 23<br>
name = "Adam"<br>
#форматирование возраста<br>
print("{p.name}'s age is: {p.age}".format(p=Person()))<br>
<br>
Вывод этой программы:
<pre>
Adam's age is: 23</pre>
Здесь объект Person передается как аргумент-ключевое слово p .<br>
В шаблоне строки получают доступ к значениям name и age с помощью .name и .age .<br>
**Пример №9**: форматирование элементов словаря с format().<br>
#объявляем словарь person<br>
person = {'age': 23, 'name': 'Adam'}<br>
#форматирование возраста<br>
print("{p[name]}'s age is: {p[age]}".format(p=person))<br>
Вывод:
<pre>
Adam's age is: 23</pre>
По аналогии с классом словарь person передается в качестве аргумента-ключевого
слова p .<br>
В шаблоне строки доступ к name и age получают с помощью [name] и [age] .<br>
Есть и более простой способ форматировать словари в Python с
помощью str.fromat(**mapping) .<br>
#объявляем словарь person<br>
person = {'age': 23, 'name': 'Adam'}<br>
#форматирование возраста<br>
print("{name}'s age is: {age}".format(**person))<br>
Вывод:
<pre>
Adam's age is: 23</pre>
* — это параметр формата (минимальная ширина поля).<br>
#### Аргументы как параметры в format()
Параметры, такие как точность, выравнивание или символы заполнения можно
передавать в качестве позиционных аргументов-ключевых слов.<br>
**Пример №10**: динамическое форматирование.<br>
#динамический шаблон формата строки<br>
string = "{:{fill}{align}{width}}"<br>
#передача кодов формата в качестве аргументов<br>
print(string.format('cat', fill='*', align='^', width=5))<br>
#динамический шаблон формата float<br>
num = "{:{align}{width}.{precision}f}"<br>
#передача кодов формата в качестве аргументов<br>
print(num.format(123.236, align='<', width=8, precision=2))<br>
Вывод:
<pre>
*cat*
123.24
</pre>

Здесь:

В первом пример “cat” — это позиционный аргумент, который будет отформатирован.<br>
Аналогично fill='*' , align='^' и width=5 являются аргументами-ключевыми
словами.<br>
В шаблоне строки эти аргументы извлекаются не как обычные строки для вывода, а как
коды форматирования: fill , align и width .<br>
Эти аргументы заменяют соответствующие заполнители, а строка “cat” соответствующим
образом форматируется.<br>
Во втором примере 123.236 — это позиционный аргумент,
а align , with и precision передаются в шаблон в качестве параметров
форматирования.<br>
#### Дополнительные параметры форматирования с format()
format() также поддерживает форматирования по типам, например, для datetime или
форматирование сложных чисел. Он внутренне вызывает __format__() для datetime и
получает доступ к атрибутам сложных чисел.<br>
Можно запросто переопределить метод __format__() для любого объекта для создания
собственного форматирования.<br>
**Пример №11**: форматирование по типу с format() и переопределение
метода _format().<br>
import datetime<br>
#datetime форматирование<br>
date = datetime.datetime.now()<br>
print("It's now: {:%Y/%m/%d %H:%M:%S}".format(date))<br>
#форматирование комплексных чисел<br>
complexNumber = 1+2j<br>
print("Real part: {0.real} and Imaginary part: {0.imag}".format(complexNumber))<br>
#пользовательский метод __format__()<br>
class Person:
<pre>
def __format__(self, format):
if(format == 'age'):
return '23'
return 'None'
print("Adam's age is: {:age}".format(Person()))
</pre>  
Вывод:
<pre>
It's now: 2020/01/18 12:19:24
Real part: 1.0 and Imaginary part: 2.0
Adam's age is: 23
</pre>  
Здесь<br>  
Для datetime:<br>
Текущий объект datetime передается в качестве позиционного аргумента
методу format() . <br>С помощью метода __format__() format() получает доступ к
году, месяцу, дню, часу, минутам и секундам.<br>
Для сложны чисел:<br>  
1+2j конвертируется в объект ComplexNumber.
Затем через доступ к атрибутам real и imag числа форматируются.<br>
Переопределение format(): <br>
Как и с datetime можно перезаписать метод __format__() для собственного
форматирования, которое вернет возраст при попытке получить доступ через {:age} .<br>
Также можно использовать функциональность __str__() и __repr__() объекта с
условными обозначениями и format() .<br>
Как и __format__() можно запросто переопределять метода __str__() и __repr__() объекта.<br>  
**Пример №12** : условные обозначения str() и repr() (!r и !s) с format().<br>
#__str__() и __repr__() сокращенно !r и !s<br>
print("Quotes: {0!r}, Without Quotes: {0!s}".format("cat"))<br>
#реализация для класса __str__() и __repr__()<br>
class Person:
 <pre> 
def __str__(self):
return "STR"
def __repr__(self):
return "REPR"
print("repr: {p!r}, str: {p!s}".format(p=Person()))
 </pre>   
Вывод:
<pre>
Quotes: 'cat', Without Quotes: cat
repr: REPR, str: STR</pre>
