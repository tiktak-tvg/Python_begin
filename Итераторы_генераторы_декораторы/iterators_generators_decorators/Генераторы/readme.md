# Генераторы

## Оглавление
1. Введение
2. Генераторы
3. Конвейеры генераторов
***

### Введение
В прошлом уроке мы реализовывали собственные итераторы путем создания классов, содержащих два магических метода ``__iter__()`` и ``__next__()`` для поддержания протокола итератора. Делать это было несложно, однако достаточно долго и не очень удобно.<br>
В Python создавать собственные итераторы можно намного проще с помощью генераторов, которые делятся на два типа:<br>
- функции генераторы
- выражения генераторы

В этом уроке речь пойдет о функциях генераторах.<br>
#### Функции генераторы
Функция генератор – это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того,что использует выражение ``yield``, а не ``return``.<br>
Когда вызывается обычная функция, она получает личное пространство имен, в котором создаются ее локальные переменные.<br> 
Когда обычная функция достигает оператора return, локальные переменные уничтожаются и значение возвращается вызывающей стороне.<br> 
Последующий вызов той же функции создает новое локальное пространство имен и новый набор локальных переменных.<br>
Функция генератор, напротив сохраняет локальные переменные от вызова к вызову. Это своего рода возобновляемая функция.<br>
Рассмотрим пример функции генератора, которая порождает последовательность целых чисел от 00 (включительно) до ``n`` (не включительно).<br>
> Пример кода
```python   
def generate_ints(n):
for num in range(n):
yield num

generator1 = generate_ints(5) # создаем генератор, порождающий числа 0 1 2 3 4
print(type(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
generator2 = generate_ints(3) # создаем генератор, порождающий числа 0 1 2
for num in generator2:
print(num)
num1, num2 = generate_ints(2) # создаем генератор, порождающий числа 0 1
print(num1, num2)
```
![image](https://github.com/user-attachments/assets/346bc6e8-5512-4549-b382-700d4d44770e)

>Вывод
```python
<class 'generator'>
0
1
2
3
4
0
1
2
0 1
```
![image](https://github.com/user-attachments/assets/02e4bf12-3237-481d-aeb2-6fcd4d749c07)

По сути, функция ``generate_ints()`` просто возвращает генератор, порождающий последовательность нужных чисел.<br>
Генератор – это итератор, который порождает значения, переданные ``yield``. Когда выполнение доходит до конца функции,
объект генератор возбуждает исключение ``StopIteration`` в полном соответствии с протоколом итератора.<br>
Работа с генератором происходит по стандартному сценарию работы с итератором.<br> Мы можем:<br>
- вызывать функцию ``next()`` для получения очередного значения генератора
- итерироваться с помощью цикла ``for`` по генератору
- распаковывать генератор
- проверять принадлежность с помощью оператора ``in``
- и т.д.

Функция генератор возвращает объект специального типа ``<class 'generator'>``, который реализует протокол итератора,
то есть является самым настоящим итератором.<br>
Как несложно понять, мы можем достичь эффекта генераторов вручную, написав свой собственный класс, поддерживающий
протокол итератора.<br>
Класс ``GenerateInts`` полностью аналогичен указанной выше функции генератору:
```python
class GenerateInts:
    def __init__(self, n):  # конструктор принимает верхнюю границу диапазона
        self.n = n
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current == self.n:
            raise StopIteration
        else:
            self.current += 1
        return self.current - 1

iterator1 = GenerateInts(5)  # создаем итератор, содержащий числа 0 1 2 3 4
print(type(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
iterator2 = GenerateInts(3)  # создаем итератор, содержащий числа 0 1 2
for num in iterator2:
    print(num)
num1, num2 = GenerateInts(2)  # создаем итератор, содержащий числа 0 1
print(num1, num2)
```
![image](https://github.com/user-attachments/assets/d94d6288-04ab-4af5-b205-b7f77ac47cb7)
>Вывод
```python
<class '__main__.GenerateInts'>
0
1
2
3
4
0
1
2
0 1
```
![image](https://github.com/user-attachments/assets/b51a1005-2133-44dc-b220-ce5056c2bffe)

На данном примере видно, насколько генераторные функции упрощают процесс реализации собственных итераторов, значительно сокращая количества строк кода.<br>
Обратите внимание на стиль именования класса GenerateInts и функции генератора generate_ints().<br>
Может показаться, что в теле функции генератора всегда должен быть цикл, но это необязательно.<br>
> Пример кода:
```python
def generate_1234():
    yield 1
    yield 2
    yield 3
    yield 4
print(*generate_1234())     # распаковка генератора
```
содержит определение функции генератора generate_1234(), которая порождает последовательность значений<br>
1,2,3,4 и выводит: `` 1 2 3 4 ``

#### Функции генераторы с побочными действиями
Функция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:
- вывод текста на экран
- запись данных в файл
- приостановка исполняющейся программы на некоторое время
- и т.д.
Рассмотрим определение функции генератора, которая печатает текст во время выполнения.
> Пример кода:
```python
def generate_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end')
for char in generate_AB():
    print('-->', char)
```
выводит:
```python
start
--> A
continue
--> B
end
```
Как мы уже знаем, для итерирования цикл for сначала получает итератор, то есть выполняет следующий код:
``iterator = iter(generate_AB())``<br>
а затем на каждой итерации вызывает функцию ``next(iterator)``. В теле цикла на каждой итерации печатается строка --> и значение, полученное при вызове ``next(iterator)``.<br>
Во время первой итерации и первом вызове ``next(iterator)`` генератор, перед тем как сгенерировать значение ``'A' (то есть дойти до строки yield 'A')``, сначала выполняет строку ``print('start')``.<br>
Во время второй итерации и втором вызове ``next(iterator)`` генератор, перед тем как сгенерировать значение ``'B' (то есть дойти до строки yield 'B')``, сначала выполняет строку ``print('continue')``.<br>
Во время третьей итерации и третьем вызове ``next(iterator)`` генератор выполняет строку ``print('end')`` и завершает свою работу, возбуждая исключение ``StopIteration``.<br> 
Цикл ``for`` перехватывает это исключение и нормально завершается.<br>
#### Ключевое слово return в теле функции генератора
До версии ``Python 3.3`` наличие ключевого слова return внутри функции генератора приводило к возникновению ошибки:<br>
``SyntaxError: 'return' with argument inside generator``<br>
Теперь это допускается, при этом инструкция return приводит к возбуждению исключения ``StopIteration``.<br>
> Пример кода:
```python
def generate_ints():
yield 1
yield 2
return 3
yield 4
for num in generate_ints():
print(num)
```
> выводит:
```
1
2
```







