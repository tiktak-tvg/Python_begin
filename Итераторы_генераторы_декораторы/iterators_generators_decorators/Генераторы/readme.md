# Генераторы

## Оглавление
1. Введение
2. Генераторы
3. Конвейеры генераторов
***

### Введение
В прошлом уроке мы реализовывали собственные итераторы путем создания классов, содержащих два магических метода ``__iter__()`` и ``__next__()`` для поддержания протокола итератора. Делать это было несложно, однако достаточно долго и не очень удобно.<br>
В Python создавать собственные итераторы можно намного проще с помощью генераторов, которые делятся на два типа:<br>
- функции генераторы
- выражения генераторы

В этом уроке речь пойдет о функциях генераторах.<br>
#### Функции генераторы
Функция генератор – это функция, которая возвращает итератор. Она выглядит как обычная функция, за исключением того,что использует выражение ``yield``, а не ``return``.<br>
Когда вызывается обычная функция, она получает личное пространство имен, в котором создаются ее локальные переменные.<br> 
Когда обычная функция достигает оператора return, локальные переменные уничтожаются и значение возвращается вызывающей стороне.<br> 
Последующий вызов той же функции создает новое локальное пространство имен и новый набор локальных переменных.<br>
Функция генератор, напротив сохраняет локальные переменные от вызова к вызову. Это своего рода возобновляемая функция.<br>
Рассмотрим пример функции генератора, которая порождает последовательность целых чисел от 00 (включительно) до ``n`` (не включительно).<br>
> Пример кода
```python   
def generate_ints(n):
    for num in range(n):
        yield num

generator1 = generate_ints(5) # создаем генератор, порождающий числа 0 1 2 3 4
print(type(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
print(next(generator1))
generator2 = generate_ints(3) # создаем генератор, порождающий числа 0 1 2
for num in generator2:
    print(num)
num1, num2 = generate_ints(2) # создаем генератор, порождающий числа 0 1
print(num1, num2)
```
![image](https://github.com/user-attachments/assets/346bc6e8-5512-4549-b382-700d4d44770e)

>Вывод
```python
<class 'generator'>
0
1
2
3
4
0
1
2
0 1
```
![image](https://github.com/user-attachments/assets/02e4bf12-3237-481d-aeb2-6fcd4d749c07)

По сути, функция ``generate_ints()`` просто возвращает генератор, порождающий последовательность нужных чисел.<br>
Генератор – это итератор, который порождает значения, переданные ``yield``. Когда выполнение доходит до конца функции,
объект генератор возбуждает исключение ``StopIteration`` в полном соответствии с протоколом итератора.<br>
Работа с генератором происходит по стандартному сценарию работы с итератором.<br> Мы можем:<br>
- вызывать функцию ``next()`` для получения очередного значения генератора
- итерироваться с помощью цикла ``for`` по генератору
- распаковывать генератор
- проверять принадлежность с помощью оператора ``in``
- и т.д.

Функция генератор возвращает объект специального типа ``<class 'generator'>``, который реализует протокол итератора,
то есть является самым настоящим итератором.<br>
Как несложно понять, мы можем достичь эффекта генераторов вручную, написав свой собственный класс, поддерживающий
протокол итератора.<br>
Класс ``GenerateInts`` полностью аналогичен указанной выше функции генератору:
```python
class GenerateInts:
    def __init__(self, n):  # конструктор принимает верхнюю границу диапазона
        self.n = n
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current == self.n:
            raise StopIteration
        else:
            self.current += 1
        return self.current - 1

iterator1 = GenerateInts(5)  # создаем итератор, содержащий числа 0 1 2 3 4
print(type(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
print(next(iterator1))
iterator2 = GenerateInts(3)  # создаем итератор, содержащий числа 0 1 2
for num in iterator2:
    print(num)
num1, num2 = GenerateInts(2)  # создаем итератор, содержащий числа 0 1
print(num1, num2)
```
![image](https://github.com/user-attachments/assets/d94d6288-04ab-4af5-b205-b7f77ac47cb7)
>Вывод
```python
<class '__main__.GenerateInts'>
0
1
2
3
4
0
1
2
0 1
```
![image](https://github.com/user-attachments/assets/b51a1005-2133-44dc-b220-ce5056c2bffe)

На данном примере видно, насколько генераторные функции упрощают процесс реализации собственных итераторов, значительно сокращая количества строк кода.<br>
Обратите внимание на стиль именования класса GenerateInts и функции генератора generate_ints().<br>
Может показаться, что в теле функции генератора всегда должен быть цикл, но это необязательно.<br>
> Пример кода:
```python
def generate_1234():
    yield 1
    yield 2
    yield 3
    yield 4
print(*generate_1234())     # распаковка генератора
```
содержит определение функции генератора generate_1234(), которая порождает последовательность значений<br>
1,2,3,4 и выводит: `` 1 2 3 4 ``

#### Функции генераторы с побочными действиями
Функция генератор может не только порождать значения, но и совершать различные побочные действия во время выполнения, такие как:
- вывод текста на экран
- запись данных в файл
- приостановка исполняющейся программы на некоторое время
- и т.д.
Рассмотрим определение функции генератора, которая печатает текст во время выполнения.
> Пример кода:
```python
def generate_AB():
    print('start')
    yield 'A'
    print('continue')
    yield 'B'
    print('end')
for char in generate_AB():
    print('-->', char)
```
выводит:
```python
start
--> A
continue
--> B
end
```
Как мы уже знаем, для итерирования цикл for сначала получает итератор, то есть выполняет следующий код:
``iterator = iter(generate_AB())``<br>
а затем на каждой итерации вызывает функцию ``next(iterator)``. В теле цикла на каждой итерации печатается строка --> и значение, полученное при вызове ``next(iterator)``.<br>
Во время первой итерации и первом вызове ``next(iterator)`` генератор, перед тем как сгенерировать значение ``'A' (то есть дойти до строки yield 'A')``, сначала выполняет строку ``print('start')``.<br>
Во время второй итерации и втором вызове ``next(iterator)`` генератор, перед тем как сгенерировать значение ``'B' (то есть дойти до строки yield 'B')``, сначала выполняет строку ``print('continue')``.<br>
Во время третьей итерации и третьем вызове ``next(iterator)`` генератор выполняет строку ``print('end')`` и завершает свою работу, возбуждая исключение ``StopIteration``.<br> 
Цикл ``for`` перехватывает это исключение и нормально завершается.<br>
#### Ключевое слово return в теле функции генератора
До версии ``Python 3.3`` наличие ключевого слова return внутри функции генератора приводило к возникновению ошибки:<br>
``SyntaxError: 'return' with argument inside generator``<br>
Теперь это допускается, при этом инструкция return приводит к возбуждению исключения ``StopIteration``.<br>
> Пример кода:
```python
def generate_ints():
    yield 1
    yield 2
    return 3
    yield 4
for num in generate_ints():
    print(num)
```
> выводит:
```
1
2
```

Строка кода return 3 в функции генераторе generate_ints() возбуждает исключение StopIteration, которое перехватывает цикл for, после чего он завершается. Обратите внимание на то, что само значение 33 не выводится.

#### Особенности и ограничения функций генераторов

Основные особенности, присущие всем функциям генераторам:
- любая функция, содержащая ключевое слово yield, является функцией генератором
- когда вызывается функция генератор, то она не возвращает единственное значение, как это делает обыкновенная функция
- функция генератор всегда возвращает объект типа generator, который поддерживает протокол итератора

Разница между yield и оператором return заключается в том, что для ключевого слова yield состояние выполнения генератора приостанавливается и локальные переменные сохраняются.<br> 
При следующем вызове метода генератора __next__() функция возобновляет свое выполнение из той точки, из которой завершила в прошлый раз.<br>
Генератор является итератором, поэтому он обладает всеми его особенностями:
- нельзя получить длину генератора функцией len()
- нельзя распечатать элементы генератора функцией print() без предварительной распаковки
- у генератора нельзя получить элемент по индексу
- после итерации по генератору он становится пустым

#### Примеры использования функций генераторов
В прошлом уроке мы рассматривали примеры по созданию собственных итераторов с помощью создания соответствующих классов.<br> 
Давайте перепишем их с использованием функций генераторов.

> Пример 1. Реализуем функцию генератор counter(), которая возвращает генератор, порождающий последовательность целых чисел значения low до high включительно с шагом один. Значения low и high передаются в качестве аргументов в функцию генератор.<br>
Реализация функции генератора:
> Пример кода:
```python
def counter(low, high):
    for num in range(low, high + 1):
        yield num

counter1 = counter(3, 10)
for i in counter1:
    print(i)
counter2 = counter(100, 103)
print(next(counter2))
print(next(counter2))
```
![image](https://github.com/user-attachments/assets/712c5d5e-99c0-4839-b4cd-decdfd623222)
> выводит:
```python
3
4
5
6
7
8
9
10
100
101
``` 
> Пример 2. Реализуем функцию генератор even_numbers(), которая возвращает генератор, порождающий бесконечную последовательность целых четных чисел от значения begin.<br>
Значение begin передается в качестве аргумента в функцию генератор.<br>
Реализация функции генератора:
> Пример кода:
```python
def even_numbers(begin):
    begin += begin % 2
    while True:
        yield begin
        begin += 2

evens1 = even_numbers(10)   # все четные числа от 10 до бесконечности
for index, num in enumerate(evens1):
    if index > 5:
        break
    print(num)
evens2 = even_numbers(101)  # все четные числа от 102 до бесконечности
print(next(evens2))
print(next(evens2))
print(next(evens2))
print(next(evens2))
```
![image](https://github.com/user-attachments/assets/23b85976-f7d8-4f92-aceb-a57e881bbee3)
> выводит:
```python
10
12
14
16
18
20
102
104
106
108
```
> Пример 3. Реализуем функцию генератор string_wrapper, которая возвращает генератор, порождающий последовательность символов строки text, обрамленных специальным символом symbol.<br>
Значения text и symbol передаются в качестве аргументов в функцию генератор.<br>
Реализация функции генератора:
> Пример кода:
```python
def string_wrapper(text, symbol):
    for char in text:
        yield symbol + char + symbol

string_wrapper1 = string_wrapper('beegeek', '~')
for char in string_wrapper1:
    print(char)
string_wrapper2 = string_wrapper('Python', '+')
print(next(string_wrapper2))
print(next(string_wrapper2))
print(next(string_wrapper2))
print(list(string_wrapper('stepik', '-')))
```
> выводит:
```python
~b~
~e~
~e~
~g~
~e~
~e~
~k~
+P+
+y+
+t+
['-s-', '-t-', '-e-', '-p-', '-i-', '-k-']
```
> Пример 4. Реализуем функцию генератор factorials(), которая возвращает генератор, порождающий бесконечную
последовательность факториалов всех натуральных чисел (от 11 до бесконечности). Функция генератор не принимает
аргументов.
Реализация функции генератора:
> Пример кода:
```python
def factorials():
    value = 1
    index = 1
    while True:
        yield value
        index += 1
        value *= index

infinite_factorials = factorials()
for index, num in enumerate(infinite_factorials, 1):
    if index <= 10:
        print(f'Факториал числа {index} равен {num}')
```
![image](https://github.com/user-attachments/assets/2675ce6a-01e5-4037-9c28-11b195b4243f)
> выводит:
```python
Факториал числа 1 равен 1
Факториал числа 2 равен 2
Факториал числа 3 равен 6
Факториал числа 4 равен 24
Факториал числа 5 равен 120
Факториал числа 6 равен 720
Факториал числа 7 равен 5040
Факториал числа 8 равен 40320
Факториал числа 9 равен 362880
Факториал числа 10 равен 3628800
```

> Примечание 1. Функция генератор и генераторная функция – это одно и то же.
> Примечание 2. Любой итератор является итерируемым объектом, в то время как любой генератор является итератором, а значит и итерируемым объектом.
![image](https://github.com/user-attachments/assets/46344c71-6604-4333-a4d1-92cca2b19ac8)
> Пример кода:
```python
def generate_1():
    yield 1
gen = generate_1()
print(dir(gen))
```
выводит список всех атрибутов генератора, среди которых есть методы __iter__() и __next__():
```python
['__class__', '__del__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__name__', '__ne__', '__new__', '__next__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']
```
> Примечание 4. Итерируемый объект и итератор – это протоколы, то есть правила реализации. Генератор – это не протокол, а конкретная реализация. Это специальный механизм в языке Python, который позволяет создать однократно перебираемую функцию, логика перебора которой легко и красиво описывается.
> Примечание 5. Единственное синтаксическое различие между обычной функцией и функцией генератором – тот факт, что в теле последней встречается ключевое слово yield. Многие разработчики из команды Python считали, что для функций генераторов следовало бы ввести новое ключевое слово gen вместо def, но Гвидо не согласился.

## Генераторы 




