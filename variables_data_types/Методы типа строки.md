# Методы типа строки.
#### Строковые значения.
Строковое значение записывается как последовательность символов, заключённая в одинарные или двойные кавычки: А.
```
s = 'abcdefgh'
f = s [2]    # значение переменной f равно 'с'
print(в[0]) # будет выведен символ 'а'
```

Программа на языке Python состоит из логических строк. Инструкции не могут быть разделены на несколько логических строк, за исключением составных инструкций. Логическая строка составляется из одной или нескольких физических строк, следуя правилам явного или подразумеваемого объединения строк. Отступ в физической строке, являющейся продолжением логической строки, не имеет значения.

Две или более физических строки могут быть объединены в логическую строку явно с помощью символа обратной косой черты (‘\’): если физическая строка заканчивается символом обратной косой черты, который не является частью строкового литерала или комментария, она объединяется со следующей физической строкой, образуя одну логическую строку. <br>Например:
```
if 1900 < year < 2100 and 1 <= month <= 12 \
and 1 <= day <= 31 and 0 <= hour < 24 \
and 0 <= minute < 60 and 0 <= second < 60:
# Похоже на правильную дату
return 1
```
Ñòðóêòóðà ñòðîê ïðîãðàììû

С помощью метода len() можно узнать количество символов в строке:
```
len('Python')
Вывод: 6
```
Методов работы со строками довольно много, мы рассмотрим часть наиболее популярных:
- center(width) #если длина строки меньше параметра width, то слева и справа от строки равномерно добавляются пробелы, чтобы дополнить значение width, а сама строка выравнивается по центру
```
txt = "Python"
x = txt.center(20)
print(x)
Вывод:       Python
*************************
txt = "Python"
x = txt.center(40)
print(x)
Вывод:                  Python
```  
- find(str, [start],[end])      #Поиск подстроки в строке. Возвращает номер первого вхождения или -1
```
s = 'PythonohtyP'
s.find('t')
Вывод: 2
```  
- rfind(str, [start],[end])     #Поиск подстроки в строке. Возвращает номер последнего вхожденияили -1
```
s = 'PythonohtyP'
s.rfind('t')
Вывод: 8
```  
- index(str, [start],[end])     #Поиск подстроки в строке. Возвращает номер первого вхождения иливызывает **ValueError**
```
s = 'Python'
s.index('t')
Вывод: 2
```  
- rindex(str, [start],[end])    #Поиск подстроки в строке. Возвращает номер последнего вхожденияили вызывает **ValueError**
```
s = 'PythonohtyP'
s.rindex('t')
Вывод: 8
```  
- replace(шаблон, замена)       #Замена шаблона
```
s = 'Python'
s.replace('P','AAA')
Вывод: AAAython
*****************************
phone = "+1-234-567-89-10"
 
# замена дефисов на пробел
edited_phone = phone.replace("-", " ")
print(edited_phone)
Вывод:  +1 234 567 89 10
 
# удаление дефисов
edited_phone = phone.replace("-", "")
print(edited_phone)
Вывод:  +12345678910
 
# замена только первого дефиса
edited_phone = phone.replace("-", "", 1)
print(edited_phone)
Вывод:  +1234-567-89-10

```  
- split(символ)                 #Разбиение строки по разделителю
```
s = 'Python'
s.split('t')
Вывод: ['Py','hon']
```
- isdigit()                     #Состоит ли строка из цифр
```
s = 'Python'
s.isdigit()
Вывод: False
```
- isalpha()                     #Состоит ли строка из букв
```
s = 'Python'
s.isalpha()
Вывод: True
```
- isalnum()                     #Состоит ли строка из цифр или букв
```
s = 'Python'
s.isalnum() 
Вывод: False
```
- islower()  #Состоит ли строка из символов в нижнем регистре
```
s = 'Python'
s.islower()
Вывод: False
```
- isupper()                     #Состоит ли строка из символов в верхнем регистре
```
s = 'Python'
s.isupper()
Вывод: False
```
- istitle()                     #Начинаются ли слова в строке с заглавной буквы
```
s = 'Python'
s.istitle()
Вывод: True
```
- upper()                       #Преобразование строки к верхнему регистру
```
s = 'Python'
s.upper()
Вывод: 'PYTHON'
```
- lower()                       #Преобразование строки к нижнему регистру
```
s = 'Python'
s.lower()
Вывод: 'python'
```
- partition()     #разбивает строку по разделителю на три подстроки и возвращает кортеж из трех элементов - подстрока до разделителя, разделитель и подстрока после разделителя
```
text = "Это был огромный, в два обхвата дуб, с обломанными ветвями и с обломанной корой"
text_parts = text.partition("дуб")
print(text_parts)

Вывод: ('Это был огромный, в два обхвата ', 'дуб', ', с обломанными ветвями и с обломанной корой')
```
- startswith(str)               #Начинается ли строка ``S``с шаблона ``str``
```
s = 'Python'
s.startswith('P')
Вывод: True
```  
- endswith(str)                     #Заканчивается ли строка ``S`` шаблоном ``str``
```
s = 'Python'
s.endswith('a') 
Вывод: False
``` 
- join(список)                     #Сборка строки из списка с разделителем ``S``
```
s = 'Python'
s.join('a','b','c') 
Вывод: 'aPythonbPythonc'
*********************************
words = ["Let", "me", "speak", "from", "my", "heart", "in", "English"]
 
# разделитель - пробел
sentence = " ".join(words)
print(sentence)
Вывод: Let me speak from my heart in English
********************************* 
# разделитель - вертикальная черта
sentence = " | ".join(words)
print(sentence)
Вывод: Let | me | speak | from | my | heart | in | English

```

- Метод разбиения строки по разделителю:

```
S = 'Cat, Dog,Hamster   Rabbit, Pig'
print(S.split())          # Разделитель не задан. Метод разбивает строку по пробельным символам — пробелу и знаку табуляции
print(S.split(','))       # Разбивает строку по заданному разделителю ','
print(S.split(',', 2))    # Задаёт максимальное количество разбиений, равное 3
**********
Вывод: 
['Cat,', 'Dog,Hamster', 'Rabbit,', 'Pig']
['Cat', ' Dog', 'Hamster   Rabbit', ' Pig']
['Cat', ' Dog', 'Hamster   Rabbit, Pig']
```
- Методы rjust() и ljust():

```
S = 'Hi!'
print(S.rjust(10,'*')) # Увеличивает длину строки до 10 и заполняет пробелы слева символами '*'
print(S.ljust(10,'*')) # Увеличивает длину строки до 10 и заполняет пробелы справа символами '*'

Вывод: 
*******Hi!
Hi!*******
```

Методы, которые доступны со списком объектов в программировании на Python, приведены в таблицениже. Они доступны как ``list.method()``. Некоторые из методов уже были использованы выше.<br>
Методы списка Python:

- append ()                     #добавляет элемент в конец списка

- extend ()                    #добавляет все элементы списка в другой список

- insert ()                     #вставить элемент по указанному индексу

- remove ()                     #удаляет элемент из списка

- pop ()                     #удаляет и возвращает элемент по указанному индексу

- clear ()                     #удаляет все элементы из списка

- index ()                     #возвращает индекс первого соответствующего элемента

- count ()                     #Возвращает количество элементов, переданных в качестве аргумента.

- sort ()                     #сортировка элементов в списке в порядке возрастания

- reverse ()                     #обратный порядок элементов в списке

- copy ()                     #возвращает поверхностную копию списка.

Некоторые примеры методов списка Python:

```
my_list = [3, 8, 1, 6, 0, 8, 4]
print(my_list.index(8))
Вывод: 1

my_list = [3, 8, 1, 6, 0, 8, 4]
print(my_list.count(8))
Вывод: 2

my_list = [3, 8, 1, 6, 0, 8, 4]
my_list.sort()
print(my_list)
Вывод: [0, 1, 3, 4, 6, 8, 8]

my_list = [3, 8, 1, 6, 0, 8, 4]
my_list.reverse()
print(my_list)
Вывод: [4, 8, 0, 6, 1, 8, 3]
```

Количество элементов в списке можно узнать с помощью функции ``len()``:

```
my_list = [3, 8, 1, 6, 0, 8, 4]
print(len(my_list))
Вывод: 7
```

Метод ``copy()`` поверхностная копия списка, при присвоении переменной копии списка, значениеданного списка не изменяется в случае изменения первого. Если переменной присвоить список через ``"="``, тогда значение этой переменной
будет меняться при изменении оригинала.<br>
Данный модуль предоставляет общие (поверхностная и глубокая) операции копирования.

- copy.copy(x) - возвращает поверхностную копию x.

- copy.deepcopy(x) - возвращает полную копию x.

```
import copy
a = [1, 2, 3, [1, 2, 3]]
test_copy = copy.copy(a)
print(a, test_copy)
Вывод: [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3]]
test_copy[3].append(4)
print(a, test_copy)
Вывод: [1, 2, 3, [1, 2, 3, 4]] [1, 2, 3, [1, 2, 3, 4]]
b = [1, 2, 3, [1, 2, 3]]
test_deepcopy = copy.deepcopy(b)
test_deepcopy[3].append(4)
print(b, test_deepcopy)
Вывод: [1, 2, 3, [1, 2, 3]] [1, 2, 3, [1, 2, 3, 4]]
```

Мы можем проверить, присутствие элементов в списке, используя ключевое слово in:

```
my_list = [3, 8, 1, 6, 0, 8, 4]
print(8 in my_list)
Вывод: True

my_list = [3, 8, 1, 6, 0, 8, 4]
print('8' in my_list)
Вывод: False

my_list = [3, 8, 1, 6, 0, 8, 4]
print(9 in my_list)
Вывод: False

my_list = ['H', 'e', 'l', 'l', 'o']
print('o' in my_list)
Вывод: True
```




