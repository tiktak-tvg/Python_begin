### Задачи на регулярное выражение.
Перед тем как вы приступите к представленным упражнениям, мы бы хотели немного рассказать о задачах, в которых требуется написать регулярное выражение. Рассмотрим пару таких задач и дадим несколько комментариев относительно их оформления.<br>
Задача 1. Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствует строка Hello.
<pre>regex = r''</pre>
Решение. В задаче требуется реализовать регулярное выражение и присвоить его переменной regex. Регулярное выражение, которому соответствует строка Hello представляет собой саму строку Hello.<br>
Итак, наше регулярное выражение имеет вид:
<pre>regex = r'Hello'</pre>
Приведенный выше код является ответом на задачу, и именно его следует вставить в окошко ввода. Дополнительно считывать\выводить данные не нужно, требуется лишь реализовать регулярное выражение и присвоить его указанной переменной.

Задача 2. Дополните приведенный ниже код, чтобы переменная regex содержала регулярное выражение, которому соответствуют трехсимвольные цифровые последовательности.
<pre>regex = r''</pre>
Решение. В задаче требуется реализовать регулярное выражение и присвоить его переменной regex. Для решения воспользуемся метасимволом \d, соответствующим любой цифре.<br>
Итак, наше регулярное выражение может иметь вид:
<pre>regex = r'\d\d\d'</pre>
Приведенный выше код является ответом на задачу, и именно его следует вставить в окошко ввода. Дополнительно считывать\выводить данные не нужно, требуется лишь реализовать регулярное выражение и присвоить его указанной переменной.<br>
> Примечания<br>
**Примечание.** В задачах на регулярное выражение нет входных и выходных данных, тем не менее в тестовых данных вы увидите строки текста и соответствующий вывод: это именно то, как мы будем тестировать реализованное вами регулярное выражение.<br> 
Sample Input представляет строку, в которой осуществляется поиск, Sample Output — список всех значений, указанных через пробел, которые должны быть найдены в данной строке реализованным вами регулярным выражением.<br>
### Соответствие одному из нескольких символов.
Как мы уже знаем, точке . соответствует один произвольный символ, однако на практике часто требуется искать конкретные символы. В регулярных выражениях набор символов определяется с помощью метасимволов [ и ]. Метасимволы [ и ] определяют набор допустимых символов.<br>
Регулярному выражению:
<pre>[ns]a.\.csv</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
Используемое здесь регулярное выражение начинается с [ns], которое соответствует либо символу n, либо символу s.<br>
Символы [ и ] не соответствуют никаким символам, они определяют набор. Символ a соответствует a, точке . соответствует любой символ, наклонной черте с точкой \. соответствует символ ., а последовательности символов csv соответствует csv.<br>
Наборы символов часто используются для выполнения поиска, не зависящего от регистра.<br> 
Регулярному выражению:
<pre>
[Rr]eg[Ee]x
</pre>
в тексте:
<pre>
The phrase "regular expression" is often abbreviated as RegEx or regex.
</pre>
соответствует (выделено жирным шрифтом):
<pre>
The phrase "regular expression" is often abbreviated as RegEx or regex.
</pre>
Используемое здесь регулярное выражение содержит два набора символов: [Rr], которому соответствуют символы R и r, и [Ee], которому соответствуют символы E и e. Именно поэтому мы нашли как RegEx, так и regex. Однако, например, последовательность символов REGEX не была бы найдена.<br>
### Использование диапазона набора символов.
Как уже было показано выше, регулярному выражению:
<pre>
[ns]a.\.csv
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
Файл sam.csv был найден, потому что точке . соответствуют все символы, а не только цифры. Что если нам нужно избавиться от файла sam.csv, оставив только файлы na1.csv, na2.csv и sa1.csv? Наборы символов могут решить эту проблему.<br>
Регулярному выражению:
<pre>
[ns]a[0123456789]\.csv
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
В этом примере регулярное выражение было изменено так, чтобы первый символ был либо n, либо s, второй символ – только a, третьим символом могла быть любая цифра. При этом файл sam.csv не был найден, так как m не соответствует списку допустимых символов.<br>
При работе с регулярными выражениями часто приходится определять диапазоны символов (от 0 до 9, от A до Z и т.д.). Чтобы упростить работу с символьными диапазонами, в регулярных выражениях для определения диапазонов используется специальный метасимвол: дефис -.<br>
Символ дефис - рассматривается как специальный метасимвол только тогда, когда он используется в диапазоне, то есть<br>
между ``[ и ]``. Вне диапазона символ - является обычным символом и соответствует только самому себе. Поэтому вне диапазона символу - не должен предшествовать никакой специальных символ.<br>
Регулярному выражению:
<pre>
[ns]a[0-9]\.csv
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
Регулярное выражение ``[0-9]`` функционально эквивалентно выражению ``[0123456789]``.<br>
Диапазоны могут состоять не только из цифр. Приведем примеры правильных (допустимых) диапазонов:

  - [x] [A-Z] соответствует всем символам латинского алфавита верхнего регистра от A до Z
  - [x] [a-z] соответствует всем символам латинского алфавита нижнего регистра от a до z
  - [x] [A-F] соответствует всем символам латинского алфавита верхнего регистра от A до F
  - [x] [А-Я] соответствует всем символам русского алфавита верхнего регистра от А до Я
  - [x] [а-ф] соответствует всем символам русского алфавита нижнего регистра от а до ф

Любые два символа ASCII (UTF-8) могут быть определены как начало и конец диапазона. Однако обычно диапазоны составляются из некоторых (или всех) цифр и некоторых (или всех) алфавитных символов.<br>
При использовании диапазонов нужно следить, чтобы конец диапазона не был меньше, чем его начало. К примеру, диапазоны ``[4-1]`` или ``[z-a]`` недопустимы.<br>
Мы также можем объединить несколько диапазонов в один.<br> 
Регулярные выражения:
<pre>
[A-Za-z0-9] 
[12a-p34]
</pre>
являются сокращением для:
<pre>
[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789] 
[12abcdefghijklmnop34]
</pre>
Несложно заметить, что диапазоны намного сокращают запись регулярных выражений.<br> 
Соответствие с чем угодно. Наборы символов обычно используются для того, чтобы определить список символов, любой из которых может соответствовать одному символу.<br> 
Но иногда проще указать список символов, ни с одним из которых не должен совпадать данный символ. Другими словами, нужно указать соответствие с чем угодно, кроме того, что указано в наборе символов.<br>
Вместо того, чтобы перечислять каждый символ, можно инвертировать наборы символов, используя метасимвол ``^``. <br>
Регулярному выражению:
<pre>
[ns]a[^0-9]\.csv
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
Диапазон ``[0-9]`` соответствует всем цифрам (и только цифрам). Выражение ``[^0-9]`` соответствует чему угодно, кроме цифр указанного диапазона.<br> 
Именно поэтому приведенное регулярное выражение нашло sam.csv, но не нашло ``na1.csv``, ``na2.csv`` и ``sa1.csv``.<br>
Метасимвол ``^`` отрицает все символы или диапазоны в наборе, а не только символ или диапазон, которому он предшествует.<br>
Соответствие одному из нескольких регулярных выражений<br>
Символ вертикальной черты ``|`` выполняет роль логического оператора ИЛИ в регулярных выражениях и служит для задания набора альтернатив. <br>
Мы можем использовать его всегда, когда хотим найти соответствие одному из нескольких альтернативных выражений.<br>
Регулярному выражению:
<pre>
sales[0-9]|[ns]a[0-9]\.csv
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv 
ca1.csv 
</pre>
Если требуется поиск соответствий самому символу |, то в регулярном выражении ему должен предшествовать символ обратной косой черты \|.<br>
> **Примечания**

**Примечание 1.** Если требуется найти соответствие с символом - внутри диапазона, то лучше всего его указать в самом конце.<br> 
Регулярное выражение:
<pre>[1-9a-g-]</pre>
равнозначно выражению:
<pre>[123456789abcdefg-]</pre>
Аналогичные рассуждения применяются к символу ``^``.<br>
**Примечание 2.** Буква ё не входит в диапазон ``[a-я]``, а буква ``Ё`` — в диапазон ``[A-Я]``.<br> 
**Примечание 3.** Таблица соответствия некоторых метасимволов и диапазонов:
<br>
![image](https://github.com/tvgVita69/python_begin/assets/98489171/a9bb470b-f892-4364-84dd-100e158abfbb)
<br>
**Примечание 4.** Обратите внимание на то, что в пределах квадратных скобок перед символом . можно не ставить символ обратной косой черты. Регулярному выражению ``[0-5.]`` будут соответствовать цифры от 0 до 5 и точка.<br>
### Повторение совпадений.
Мы изучили практически все основные способы сопоставления с регулярным выражением, но во всех примерах чувствовалось одно серьезное ограничение, связанное с количеством нужных символов.<br>
Рассмотрим формат адреса электронной почты, например:
<pre>support@stepik.org</pre>
Используя изученные метасимволы, можно создать следующее регулярное выражение:
<pre>\w@\w\.\w </pre>
Метасимвол \w соответствует всем алфавитно-цифровым символам и символу нижнего подчеркивания.<br>
Обратите внимание на то, что символ ``@`` не является метасимволом, поэтому ему не должен предшествовать символ обратной косой черты ``\``.<br>
Такое регулярное выражение верное, однако достаточно бесполезное, поскольку соответствует электронным адресам вроде ``a@b.c``. Проблема заключается в том, что метасимвол ``\w`` соответствует одному отдельному символу, а мы не знаем заранее, сколько символов предшествует символу ``@``.<br>
Приведенные ниже адреса электронной почты:
<pre>
timyr_guev@beegeek.org 
timyr@guev.ru 
tiguev@beegeek.com 
</pre>
являются правильными (допустимыми), но они все имеют разное количество символов перед ``@``.<br>
Таким образом, нам нужен специальный синтаксис в регулярных выражениях, который позволит установить соответствие с несколькими символами.<br>
### Соответствие с одним или несколькими символами.
Символ ``+`` устанавливает соответствие с одним или более символами. Таким образом, если регулярное выражение a соответствует одному символу ``a``, то регулярное выражение ``a+`` соответствует одному или нескольким символам ``a``. <br>
Точно так же, учитывая, что регулярное выражение ``[0-9]`` соответствует любой цифре, регулярное выражение ``[0-9]+`` соответствует последовательности, состоящей из одной или нескольких цифр.<br>
Регулярному выражению:
<pre>a+[0-9]+</pre>
в тексте:
<pre>
acedia1.csv 
acediaaa1.csv 
acediaa12345.csv 
baham98.csv 
sea777.json 
shaaaaa123456789.json 
spa.doc 
naaa1.csv 
na2.csv 
sab1.csv 
cattt1.csv
</pre>
соответствует (выделено жирным шрифтом):
<pre>
acedia1.csv 
acediaaa1.csv 
acediaa12345.csv 
baham98.csv 
sea777.json 
shaaaaa123456789.json 
spa.doc 
naaa1.csv 
na2.csv 
sab1.csv 
cattt1.csv
</pre>  
Давайте повторно рассмотрим пример с адресами электронной почты, на сей раз используя ``+``, чтобы установить соответствие с одним или несколькими символами.<br>
Регулярному выражению:
<pre>\w+@\w+\.\w+</pre>
в тексте:
<pre>
Присылайте личную электронную почту по адресу timyr_guev@yandex.com. Для вопросов о предстоящих курсах используйте адрес pygen@yandex.ru. Спам можете прислать по адресу spam@beegeek.com.  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
Присылайте личную электронную почту по адресу timyr_guev@yandex.com. Для вопросов о предстоящих курсах используйте адрес pygen@yandex.ru. Спам можете прислать по адресу spam@beegeek.com.  
</pre>
Символ + является метасимволом. Если требуется поиск соответствий самому символу ``+``, то в регулярном выражении ему должен предшествовать символ обратной косой черты ``\+``.<br>
Метасимвол + может также использоваться для того чтобы установить соответствие с одним или несколькими наборами символов.<br> 
Регулярному выражению:
<pre>
[\w.]+@[\w.]+\.\w+  
</pre>
в тексте:
<pre>
  Присылайте личную электронную почту по адресу timyr.guev@yandex.com. Для вопросов о предстоящих курсах используйте адрес pygen@beegeek.school.ru. Спам можете прислать по адресу spam@beegeek.com.
</pre>
соответствует (выделено жирным шрифтом):
<pre>
 Присылайте личную электронную почту по адресу timyr.guev@yandex.com. Для вопросов о предстоящих курсах используйте адрес pygen@beegeek.school.ru. Спам можете прислать по адресу spam@beegeek.com. 
</pre>
#### Поиск нуля и большего количества символов.
Символ + устанавливает соответствие с одним или более символами. С отсутствующими символами (то есть с нулевым количеством символов) соответствие установлено не будет. Иногда возникает задача, в которой нужно установить соответствие с необязательными символами, то есть с такими символами, которые могут отсутствовать вообще.<br>
Для того чтобы установить соответствие с необязательными символами в регулярных выражениях используется метасимвол *. Метасимвол * используется в точности так, как +, он записывается сразу после символа или набора и соответствует нулю или большему количество вхождений.<br>
Регулярному выражению:
<pre>
aaa[0-9]* 
</pre>
в тексте:
<pre>
acedia1.csv 
acediaaa1.csv 
acediaa12345.csv 
baham98.csv 
sea777.json 
shaaaaa123456789.json 
spa.doc 
naaa123.csv 
na2.csv 
sab1.csv 
aaa.csv 
</pre>  
соответствует (выделено жирным шрифтом):
<pre>
acedia1.csv 
acediaaa1.csv 
acediaa12345.csv 
baham98.csv 
sea777.json 
shaaaaa123456789.json 
spa.doc 
naaa123.csv 
na2.csv 
sab1.csv 
aaa.csv 
</pre> 
Cимвол ``*`` является метасимволом. Если требуется поиск соответствий самому символу ``*``, то в регулярном выражении ему должен предшествовать символ обратной косой черты ``\*``.<br>
#### Соответствие с нулем вхождений или с вхождением одного символа
Есть еще один очень полезный метасимвол ``?``, который позволяет установить соответствие с необязательными символами. В отличие от символа ``*``, символ ``?`` соответствует только отсутствию вхождений или одному вхождению.<br>
Регулярному выражению:
<pre>
https?://[\w./]+ 
</pre>
в тексте:
<pre>
URL http://stepik.org/ уже не безопасен. Для безопасного подключения вместо него используйте https://stepik.org/ 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
URL http://stepik.org/ уже не безопасен. Для безопасного подключения вместо него используйте https://stepik.org/  
</pre>

Шаблон ``https?://`` соответствует либо ``http://``, либо ``https://``, и ничему другому.

Символ ``?`` является метасимволом. Если требуется поиск соответствий самому символу ``?``, то в регулярном выражении ему должен предшествовать символ обратной косой черты ``\?``.

#### Использование интервалов
Метасимволы ``+, * и ?`` помогают решить много проблем с регулярными выражениями, но иногда этих символов недостаточно.<br> 
Учтем, что:

- символы + и * соответствуют неограниченному числу символов. Они не дают возможности установить максимальное количество символов
- минимальное количество вхождений, указываемое с помощью символов ``+, * и ?``, равно нулю или единице. Эти метасимволы не позволяют установить минимальное количество совпадений явно 
- нет способа определить точно количество желаемых совпадений

Чтобы решить эти проблемы и обеспечить большую свободу управления повторением совпадений, в регулярных выражениях имеется возможность использования интервалов. Интервалы определяются между символами ``{`` и ``}`` .<br>
Фигурные скобки ``{`` и ``}`` являются метасимволами. Если требуется поиск соответствий самим символам ``{`` и ``}`` , то в регулярном выражении им должен предшествовать символ обратной косой черты ``\{`` и ``\}``.<br> 
#### Указание точного количества совпадений.
Чтобы определить точное количество совпадений, число совпадений указывают между фигурными скобками ``{`` и ``}`` . Поэтому ``{3}`` означает поиск соответствий с тремя экземплярами предыдущего символа или набора.<br>
Рассмотрим пример с RGB-значениями. Как мы знаем, RGB-значения определяются как три набора шестнадцатеричных чисел.<br> 
Регулярное выражение:
<pre>
#[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]  
</pre>

позволяет находить RGB-значения.<br>
Проблема с таким регулярным выражением заключается в том, что приходится повторять один и тот же набор символов шесть раз.<br> 
Указанное выше регулярное выражение можно переписать в виде:
<pre>
#[0-9A-Fa-f]{6}  
</pre>
#### Установление соответствия в случае интервала-диапазона.
Чтобы определить диапазон количества вхождений (от минимального до максимального), также используются интервалы. Диапазоны определяются, например, так: ``{2,4}``. Этот диапазон задает 2 в качестве минимального значения для количества вхождений и 4 – в качестве максимального значения для количество вхождений.
Регулярному выражению:
<pre>
\d{1,2}[-/]\d{1,2}[-/]\d{2,4}  
</pre>
в тексте:
<pre>
4/8/07
04-08-2007 
3/3/3
02-02-09  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
4/8/07
04-08-2007 
3/3/3
02-02-09   
</pre>

Шаблону ``\d{1,2}`` соответствует одна или две цифры (такая проверка используется для дня и месяца).<br> 
Шаблону ``\d{2,4}`` соответствует две, три или четыре цифры. Шаблону ``[-/]`` соответствует ``-`` или ``/`` в качестве разделителя даты. Указанное регулярное выражение нашло три даты, но не нашло 3/3/3, потому что для года последовательность цифр слишком короткая.<br> 
Регулярное выражение \d{1,2}[-/]\d{1,2}[-/]\d{2,4} не проверяет правильность дат, недопустимые даты 12-25-2022 и 34/57/9999 будут найдены. <br> 
Такое регулярное выражение проверяет лишь правильность формата.<br> 
### Установление соответствия в случае интервала типа "не менее" и "не более".
Интервалы также можно использовать для того, чтобы определить минимальное количество совпадений, не указывая при этом максимального.<br>  
Синтаксис для этого типа интервала подобен синтаксису для диапазонов, но в нем опущен максимум.<br>  
Например, шаблону ``{3,}`` означает совпадение не менее чем с 3 вхождениями.<br> 
Приведем пример регулярного выражения, которое используется, чтобы определить местонахождение всех заказов, оцененных в 100 или больше долларов.<br> 
Регулярному выражению:
<pre>
\d+: \$\d{3,}\.\d{2}  
</pre>
в тексте:
<pre>
998: $121.80 
999: $11.65 
1000: $100.99 
1001: $1290.69 
1002: $1.46 
1003: $416.90 
1004: $25.00 
</pre>  
соответствует (выделено жирным шрифтом):
<pre>
998: $121.80 
999: $11.65 
1000: $100.99 
1001: $1290.69 
1002: $1.46 
1003: $416.90 
1004: $25.00 
</pre>
Аналогично интервалам типа "не менее" мы можем работать с интервалами типа "не более".<br>  
Синтаксис для этого типа интервала подобен синтаксису для диапазонов, но в нем опущен минимум.<br>  
Например, шаблон ``{,3}`` означает совпадение не более чем с 3 вхождениями (ноль, одно, два или три).<br> 
Приведем пример регулярного выражения, которое используется, чтобы определить все заказы, оцененные менее чем в 100 долларов.<br> 
Регулярному выражению:
<pre>\d+: \$\d{,2}\.\d{2} </pre>
в тексте:
<pre>
998: $121.80 
999: $11.65 
1000: $100.99 
1001: $1290.69 
1002: $1.46 
1003: $416.90 
1004: $25.00 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
998: $121.80 
999: $11.65 
1000: $100.99 
1001: $1290.69 
1002: $1.46 
1003: $416.90 
1004: $25.00 
</pre>
> **Примечания**

**Примечание 1.** Интервалы могут начинаться с нуля. Интервал ``{0,3}`` соответствует нулю, одному, двум или трем вхождениям. <br>
**Примечание 2.** При использовании интервалов мы не должны указывать символ пробела в фигурных скобках.<br>

- Правильно: {0,3}.<br>
- Неправильно: {0, 3}.<br>

**Примечание 3.** Метасимвол + функционально эквивалентен интервалу {1,}. <br>
**Примечание 4.** Метасимвол * функционально эквивалентен интервалу {0,}.<br>
**Примечание 5.** Метасимвол ? функционально эквивалентен интервалу {0,1}. <br>
**Примечание 6.** Таблица соответствия шаблона с его описанием:
<br>
![image](https://github.com/tvgVita69/python_begin/assets/98489171/332bbb55-4955-4f3f-9c2a-c989217ae5a8)

![image](https://github.com/tvgVita69/python_begin/assets/98489171/d246de6b-e76a-4524-9758-4b3cff555f98)

<br>
**Примечание 7**. Когда символ ``+`` означает повторение набора, он должен быть помещен вне набора. Поэтому регулярное выражение ``[0-9]+`` является правильным, и ему может соответствовать непустая последовательность цифр, тогда как регулярное выражение ``[0-9+]``, хотя и является синтаксически правильным, имеет совсем другое назначение.<br> 
Регулярное выражение ``[0-9+]`` определяет набор от ``0 до 9`` и символ ``+``, поэтому ему будут соответствовать любая единственная цифра или символ ``+``.<br>
**Примечание 8.** Мы можем использовать метасимволы ``+, *, ?`` и интервалы вместе с другими метасимволами. Регулярному выражению:
<pre>dea.{3}n </pre>

в тексте:
<pre>
deacons 
deadmen 
deadens 
deadest 
deadman 
deafens 
deadpan  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
deacons 
deadmen 
deadens 
deadest 
deadman 
deafens 
deadpan  
</pre>
Таким образом, приведенное регулярное выражение ищет последовательность символов dea за которой следуют любые три символа, за которыми, в свою очередь, следует символ n.<br> 
### Жадность и ленивость.
Рассмотрим регулярное выражение, которое находит любой текст внутри тегов ``<В></В>``:
<br>
``<В>.*</В>``
<br>
Такому выражению в тексте:

```
Подписку нельзя оформить клиентам, живущим в <B>России</B>, а также <B>Беларуси</B>. Приносим свои извинения.
```
соответствует (выделено жирным шрифтом):

Подписку нельзя оформить клиентам, живущим в <B>России</B>, а также <B>Беларуси</B>. Приносим свои извинения.  

Метасимволы ``*`` и ``+`` являются жадными, то есть они ищут наибольшее возможное соответствие, а не наименьшее.<br> 
Из-за этого кажется, что соответствие начинается не с начала, а с конца текста и продолжается назад (в направлении к началу), пока не будет найдено следующее соответствие.<br>
Если нам не нужно жадное поведение, то необходимо использовать ленивые аналоги этих метасимволов (они называются ленивыми, потому что устанавливают соответствие с наименьшим, а не с наибольшим возможным количеством символов).<br>
Ленивые метасимволы определяются путем добавления в конец ? к используемому метасимволу, причем для каждого жадного метасимвола имеется ленивый эквивалент.<br>
![image](https://github.com/tvgVita69/python_begin/assets/98489171/80b8bc4a-fca4-432b-aeb4-d6c6ca590d9e)
<br>
Регулярному выражению: ``<В>.*?</В>``

в тексте:

```
Подписку нельзя оформить клиентам, живущим в <B>России</B>, а также <B>Беларуси</B>. Приносим свои извинения.  
```

соответствует (выделено жирным шрифтом):

Подписку нельзя оформить клиентам, живущим в <B>России</B>, а также <B>Беларуси</B>. Приносим свои извинения. 

<br>
Используя ленивый метасимвол ``*?``, мы добились правильного результата.<br>

> **Примечания**
 
**Примечание 1.** По умолчанию метасимволы являются жадными. Они захватывают максимально возможное количество символов. Добавление ``?`` делает их ленивыми, они начинают захватывать минимально возможное количество символов.<br>
### Подвыражения.
Как мы уже знаем, метасимволы повторения (``?`` или ``*`` или ``{2}`` и т.д) относятся к предыдущему символу или метасимволу.<br>
Разработчики HTML-документов часто размещают неразрывные пробелы между словами, чтобы гарантировать, что текст не будет разорван на строки между такими словами. <br>
Делается это с помощью специальной последовательности символов &nbsр;, которая обозначает неразрывный пробел.<br>
Регулярному выражению: ``&nbsр;{2,}``

в тексте:
<pre>
Привет, меня зовут Тимур&nbsр;Гуев, я – автор курсов по математике и Python. Наши курсы победили в Stepik Awards&nbsр;&nbsр;2021.  
</pre>

ничего не соответствует.<br>
Регулярное выражение ``&nbsр;{2,}`` должно было найти два или больше вхождений последовательности символов ``&nbsр;``. Однако оно ничего не нашло.<br> 
Все потому что диапазон ``{2,}`` определяет количество повторений того символа, который непосредственно предшествует ему, в данном случае ему предшествует точка с запятой. Последовательность символов ``&nbsp;;`` была бы найдена, в отличие от последовательности ``&nbsр;&nbsр;``.<br>
Подвыражения – части большого выражения, которые группируются так, чтобы они обрабатывались как единый объект. Подвыражения заключаются между символами ``(`` и ``)``.<br>
Символы ``(`` и ``)`` являются метасимволами. Если требуется поиск соответствий самим символам ``(`` и ``)``, то в регулярном выражении им должен предшествовать символ обратной косой черты \( и \).<br>
Регулярному выражению: ``(&nbsр;){2,}``  

в тексте:
<pre>
Привет, меня зовут Тимур&nbsр;Гуев, я – автор курсов по математике и Python. Наши курсы победили в Stepik Awards&nbsр;&nbsр;2021.  
</pre>

соответствует (выделено жирным шрифтом):

Привет, меня зовут Тимур&nbsр;Гуев, я – автор курсов по математике и Python. Наши курсы победили в Stepik Awards&nbsр;&nbsр;2021. 


Подвыражение (&nbsр;) обрабатывается как единый объект. Поэтому диапазон {2,}, который следует после него, относится ко всему подвыражению, а не только к точке с запятой.<br>
Рассмотрим еще один пример. Будем использовать регулярное выражение для поиска IP-адресов. Будем считать, что IP-адрес – это четыре числа (одно, двух или трехзначное), разделенные символом точки.<br>
Регулярному выражению: ``\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}``  

в тексте:
<pre>
Пингую сайт www.stepik.org [13.69.75.239] 32 байтами данных.  
</pre>

соответствует (выделено жирным шрифтом):

Пингую сайт www.stepik.org [13.69.75.239] 32 байтами данных.  


Каждому шаблону \d{1,3} соответствует одно из чисел в IP-адресе. Эти четыре числа разделены точками ..<br>
Шаблон \d{1,3}\. повторен три раза и поэтому также может быть записан с помощью повторения. <br>
Таким образом, регулярное выражение:
<pre>
 \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} 
</pre>

можно записать с использованием подвыражения в виде:
<pre>
(\d{1,3}\.){3}\d{1,3}  
</pre> 

Регулярное выражение (\d{1,3}\.){3}\d{1,3} не совсем точно описывает IP-адреса, поскольку не учитывает ограничение, ведь IP-адрес состоит из 4 чисел в диапазоне от 0 до 255.<br>
#### Вложенные подвыражения.
Подвыражения могут быть вложенными. Одни подвыражения могут быть вложены в другие подвыражения, которые, в свою очередь, вложены в третьи подвыражения, и т.д.<br>
Возможность вкладывать подвыражения позволяет создавать невероятно мощные регулярные выражения. Чтобы продемонстрировать использование вложенных подвыражений, мы снова рассмотрим пример с IP-адресами.<br>
Вот использованное раннее регулярное выражение:
<pre>
(\d{1,3}\.){3}\d{1,3}  
</pre>

в котором подвыражение повторено три раза, а за ним в заключении следует число. Синтаксически все правильно.<br> 
IP-адрес составлен из четырех чисел, каждое из них содержит от одной до трех цифр, причем числа отделены друг от друга точками.<br> 
Данное регулярное выражение будет соответствовать любому правильному (допустимому) IP-адресу. Но оно будет соответствовать не только правильным IP-адресам.<br>
Как было сказано выше, такое регулярное выражение не совсем точно описывает IP-адреса, поскольку не учитывает ограничение, ведь IP-адрес состоит из 4 чисел в диапазоне от 0 до 255.<br> 
А наше регулярное выражение допускает также и другие числа, выходящие за пределы требуемого диапазона (например, 345, 700, 999 и т.д.), которые недопустимы в IP-адресах.<br>
Было бы хорошо, если бы можно было определить диапазон допустимых значений, но регулярные выражения соответствуют символам. Математические вычисления – не их стихия.<br>
В некоторых отдельных случаях можно записать нужное регулярное выражение. Для этого необходимо точно определить все те цепочки, которым оно должно соответствовать, и все те цепочки, которым оно не должно соответствовать.<br> 
Приведем правила, определяющие правильные комбинации в каждом числе IP-адреса:
- любое однозначное или двузначное число
- любое трехзначное число, начинающееся с 1
- любое трехзначное число, начинающееся с 2, если вторая цифра в диапазоне от 0 до 4
- любое трехзначное число, начинающееся с 25, если третья цифра находится в диапазоне от 0 до 5

Если последовательно придерживаться этих правил, становится ясно, что действительно можно написать регулярное выражение, которое может найти все IP-адреса и только их.<br>
Нужное регулярное выражение имеет вид:
<pre>
(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((2[0-4]\d)|(25[0-5])|(1\d{2})|(\d{1,2}))  
</pre>

Рассмотрим, как работает это регулярное выражение. Прежде всего отметим, что оно работает потому, что в нем используется ряд вложенных подвыражений. Проанализируем, например, следующее выражение, содержащее 4 подвыражения:
<pre>
(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}  
</pre>
Подвыражение (\d{1,2}) находит любое число в диапазоне от 0 до 99. <br>
Подвыражение (1\d{2}) находит любое трехзначное число, начинающееся с цифры 1 (после 1 следуют любые две цифры), то есть любое число в диапазоне от 100 до 199. Подвыражение (2[0-4]\d) находит все числа от 200 до 249, а подвыражение (25[0-5]) находит числа от 250 до 255. <br>
Каждое из этих подвыражений является операндом другого подвыражения, составленного из этих подвыражений с помощью оператора ИЛИ |.<br> 
Поэтому будет выполняться поиск числа, соответствующего одному из этих подвыражений, а не всем. После диапазона чисел следует \., поэтому будет выполняться поиск точки. Так что полученное подвыражение соответствует всей последовательности цифр и точке (всему числу и точке после него).<br> 
Это подвыражение заключено в скобки, то есть само рассматривается как часть подвыражения, которое повторяется три раза с помощью {3}. В конце диапазон чисел повторяется снова, но на этот раз после него нет \., этот диапазон как раз и соответствует последнему числу в IP-адресе.<br>
Именно благодаря тому, что каждое из четырех чисел находится в диапазоне от 0 до 255, это регулярное выражение действительно находит все правильные IP-адреса и отвергает все ошибочные.<br>

> **Примечания**

**Примечание 1.** Записать регулярное выражение, которое соответствует тому, что мы хотим найти, не составляет большого труда. Намного сложнее написать регулярное выражение, которое учитывает все возможные сценарии так, чтобы это выражение не соответствовало тому, с чем мы не хотим установить соответствие.<br>
**Примечание 2.** Подвыражения используются для группировки частей регулярного выражения, они заключаются в круглые скобки ( и ). <br>
Обычно подвыражения используются для того, чтобы точно указать, к каким частям регулярного выражения относятся метасимволы повторения, и правильно определяют операнды операторов ИЛИ (|). При необходимости подвыражения могут быть вложены.<br>
**Примечание 3.** Регулярные выражения могут выглядеть весьма запутано. <br>
Ключ к пониманию их состоит в том, чтобы найти их подвыражения, а затем проанализировать и понять каждое из подвыражений по отдельности. <br>
Начинать надо с самых внутренних частей и продвигаться наружу, то есть к более сложным выражениям, состоящим из уже разобранных подвыражений. <br>
Ни в коем случае не нужно пробовать читать символ за символом с самого начала. Каким бы сложным ни было регулярное выражение, при рекомендуемом подходе оно окажется намного проще, чем показалось на первый взгляд.<br>
 
### Ссылки назад.
Предположим, что в тексте нужно найти все подряд повторяющиеся слова, то есть опечатки, где то же самое слово было по ошибке напечатано дважды.<br> 
Очевидно, что при поиске второго вхождения слова должно быть известно предыдущее слово. <br>
Ссылки назад позволяют в регулярном выражении обратиться к предыдущим совпадениям (в данном случае к ранее найденному слову).<br> 
Регулярному выражению:
<pre>
(\b\w+\b)[ ]+\1  
</pre>

в тексте:
<pre>
Это текст, в котором котором несколько слов    слов повторяются, хотя они и не   не должны повторяться повторяться.  
</pre>

соответствует (выделено жирным шрифтом):

Это текст, в котором котором несколько слов    слов повторяются, хотя они и не   не должны повторяться повторяться.  

Выражение \w+ соответствует одному или нескольким алфавитно-цифровым символам, а выражение [ ]+ соответствует любым пробелам в конце. Выражение \w заключено в круглые скобки, потому является подвыражением.<br> 
Это подвыражение используется не для того, чтобы найти повторные слова, а для того, чтобы сгруппировать символы в одно выражение, пометить его и идентифицировать для использования в дальнейшем. <br>
Заключительная часть этого регулярного выражения \1 это и есть ссылка назад на подвыражение, и всякий раз, когда подвыражению (\w+) соответствует слово, тому же слову соответствует и \1. Например, когда (\w+) соответствует слову котором, \1 также соответствует слову котором.<br>
Термин ссылка назад обозначает объект, который ссылается назад на предыдущее выражение.<br>
Таким образом, выражение \1 соответствует первому подвыражению, используемому в регулярном выражении. Выражение \2 соответствует второму подвыражению, \3 – третьему и т.д.<br>
Ссылки назад подобны переменным.<br>
Рассмотрим еще один пример, который демонстрирует необходимость в ссылках назад. В HTML-документах заголовочные теги (от H1 до H6 вместе с закрывающими тегами) позволяют определить и отформатировать тексты заголовков на WEB-страницах. <br>
Пусть нам требуется определить местонахождение всех текстов заголовков, независимо от уровня заголовка.<br>
Регулярное выражение: ``<[Нh]1>.*</[Нh]1>``
<br>
соответствует первому заголовку от Н1 до /Н1 и соответственно от h1 до /h1 (HTML-теги не зависят от регистра). <br>
Для того чтобы найти все заголовки, мы можем попробовать использовать следующее регулярное выражение:

``<[Нh][1-6]>.*</[Нh][1-6]> ``

Такому регулярному выражению в тексте:

  ```
<BODY>
<H1>Добро пожаловать на курсы BEEGEEK</H1>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.
Следующие курсы:
<H2>ООП</H2>
<h2>Алгоритмы и структуры данных</h2>
Оставайтесь с нами!
</BODY> 
```
  
соответствует (выделено жирным шрифтом):

<BODY><br>
<H1>Добро пожаловать на курсы BEEGEEK</H1><br>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.<br>
Следующие курсы:<br>
<H2>ООП</H2><br>
<h2>Алгоритмы и структуры данных</h2><br>
Оставайтесь с нами!<br>
</BODY><br> 
 
Выражение ``<[Hh]><[1-6]>`` соответствует любому тегу, открывающему заголовок (H1, H2, h2 и т.д.), а выражение ``/[Hh][1- 6]`` соответствует любому тегу, закрывающему заголовок.<br>
Такое регулярное выражение почти работает. Проблема заключается в том, что закрывающие теги не обязательно соответствует открывающим.<br>
Регулярному выражению:``<[Нh][1-6]>.*</[Нh][1-6]>``

в тексте

```
<BODY>
<H1>Добро пожаловать на курсы BEEGEEK</H1>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.
Следующие курсы:
<H2>ООП</H2>
<h2>Алгоритмы и структуры данных</h2>
Оставайтесь с нами!
</BODY> 
```

соответствует (выделено жирным шрифтом):

<BODY><br>
<H1>Добро пожаловать на курсы BEEGEEK</H1><br>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.<br>
Следующие курсы:<br>
<H2>ООП</H2><br>
<h2>Алгоритмы и структуры данных</h2><br>
Оставайтесь с нами!<br>
</BODY><br> 


Тег заголовка, начинающийся с h2 и заканчивающийся /h3, недопустим, и все же регулярное выражение нашло его. <br>
Проблема состоит в том, что вторая часть совпадения (часть соответствующая закрывающему тегу) не имеет никакой информации о первой части совпадения (части соответствующей открывающему тегу). <br>
И именно здесь ссылки назад становятся очень полезными.<br>
Регулярному выражению:
<pre>
<[Hh]([1-6])>.*</[Hh]\1>  
</pre>

в тексте:

```
<BODY>
<H1>Добро пожаловать на курсы BEEGEEK</H1>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.
Следующие курсы:
<H2>ООП</H2>
<h2>Алгоритмы и структуры данных</h2>
Оставайтесь с нами!
</BODY> 
```

соответствует (выделено жирным шрифтом):

<BODY><br>
<H1>Добро пожаловать на курсы BEEGEEK</H1><br>
Мы считаем, что настоящий программист должен понимать, как работает компьютер, обладать аналитическим мышлением и не бояться математики.<br>
Следующие курсы:<br>
<H2>ООП</H2><br>
<h2>Алгоритмы и структуры данных</h2><br>
Оставайтесь с нами!<br>
</BODY> <br>


Ссылки назад будут работать только в том случае, если выражение, на которое они ссылаются, является подвыражением (заключено в скобки).<br> 
> **Примечания**

**Примечание 1.** Подвыражения нумеруются слева направо по открывающим их скобкам, включая вложенные подвыражения. У первого подвыражения номер 1, у второго – номер 2. У выражения в целом – 0.<br>
Например, для входной строки foobar регулярное выражение ``(foo(bar))`` найдет:

![image](https://github.com/tvgVita69/python_begin/assets/98489171/b49c9e67-8477-43c0-8faa-7bc992a61838)

**Примечание 2.** На подвыражения ссылаются по их относительным позициям: \1 служит для ссылки на первое подвыражение, \7 – для ссылки на седьмое подвыражение и т.д. <br>
Этот синтаксис имеет один серьезный недостаток: перемещение и редактирование подвыражений (и таким образом изменение порядка подвыражений) может нарушить регулярное выражение, а добавление или удаление подвыражений может быть даже еще более проблематичным.<br>
Чтобы избавиться от этого недостатка, в некоторых более новых реализациях регулярных выражений (в частности в Python) поддерживается захват по имени – возможность, благодаря которой каждому подвыражению можно дать уникальное название (имя), впоследствии имя может использоваться для того чтобы обратиться к подвыражению (по этому имени, а не по его относительной позиции).<br>
В языке Python именованные подвыражения создаются с помощью синтаксиса (?P<name><regex>). При этом обращаться по имени к такому подвыражению можно так \g<name>. Об этом будет подробно рассказано в следующих уроках.<br>
**Примечание 3.** По [ссылке1](https://regexcrossword.com/), [ссылке2](https://rampion.github.io/RegHex/) и [ссылке3](https://mariolurig.com/crossword/) доступны кроссворды по регу
