# Регулярные выражения (RegularExpressions)
## Оглавление
- Видеолекция: Регулярные выражения
- Теоретическая часть по теме: Регулярные выражения
- Решение задач по теме: Регулярные выражения
- Жизнь без регулярных выражений
- Поиск заданного текста
- Задачи на регулярное выражение
- Соответствие одному из нескольких символов
- Повторение совпадений
- Жадность и ленивость
- Подвыражения
- Ссылки назад
- Модуль re
- Флаги
- Функция findall()

## Теоретическая часть по теме: Регулярные выражения
**Регулярные выражения** - выражения для поиска и замены части текста в строке или файле. Для работы с ниминеобходимо подключить модуль "re" из стандартной библиотеки Python.
Наиболее часто регулярные выражения используются для поиска в строке, разбиении строк, замены части строк.Вот некоторые методы для работы с регулярными выражениями:
<pre>
<strong>re.match(шаблон, строка)</strong> - ищет заданный шаблон с самого начала строки.
<strong>re.search(шаблон, строка)</strong> - ищет заданный шаблон по всей строке, возвращает результат при первомсовпадении.
<strong>re.findall(шаблон, строка)</strong> - ищет заданный шаблон и возвращает все совпадения в виде списка.
<strong>re.split(шаблон, строка)</strong> - разделяет строку по заданному шаблону.
<strong>re.sub(шаблон, замена, строка)</strong> - находит шаблон в строке и производит замену.
<strong>re.compile(шаблон)</strong> - позволяет собирать регулярное выражение в отдельный объект для последующегоиспользования.
</pre>
Перейдем к самой интересной части - представьте, что вам необходимо произвести чтение "грязного" файла иубрать из него все лишнее, но при этом вы не можете сказать точно, что необходимо убрать.<br> 
Эту задачу можнорешить используя специальные символы:

Рассмотрим пример. Ниже представлен фрагмент лога - файла, записывающего события при работе программы:

Фрагмент лог-файла:

![Пример_логов](https://github.com/tvgVita69/RegularExpressions/assets/98489171/275f7e83-e701-48cb-b6c1-40c7c721ac60)

В нем есть характерная строка, сообщающая, что программа не получила идентификатор пользователя приподключении:

![Пример_лог_файл](https://github.com/tvgVita69/RegularExpressions/assets/98489171/1353b6be-48e9-4b21-811e-7b4d4a16a484)

Давайте напишем программу, которая найдет все ip адреса таких неавторизованных юзеров:

![Поиск_лог_файл](https://github.com/tvgVita69/RegularExpressions/assets/98489171/92cf8f4a-ec3a-43b4-893c-c42ec566b8ff)

Мы построчно читаем файл и ищем строки, в которых есть сочетание 'Did'. В каждой такой строке мы находим ipадрес. Он состоит из 4 наборов цифр, разделенных точками между собой.

## Решение задач по теме: Регулярные выражения.

### Задача 1.
Напишите программу Python, чтобы проверить, что строка содержит только набор символов a-z, A-Z и0–9).

## Жизнь без регулярных выражений.
Работая со строковыми объектами (тип str), перед программистами часто стоит задача определения совпадения строк и/илипроверка вхождения одной строки в другую.<br>
В Python строки сравниваются посимвольно: две строки равны, если совпадают их длины и равны символы на каждой из позиций.<br>
Приведенный ниже код (см файл Сравнение.ру):
<pre>
text1 = 'python!'
text2 = 'python' + '!'
text3 = 'Python!'
print(text1 == text2)
print(text1 == text3)
</pre>
выводит:
<pre>
<strong>True</strong>
<strong>False</strong>
</pre>
Для проверки принадлежности одной строки другой можно использовать несколько механизмов:
- оператор принадлежности in 
- строковый метод index() 
- строковый метод find()

Приведенный ниже код:
<pre>
text = 'python 123 beegeek'
print('123' in text)
print(text.index('123'))
print(text.find('123'))
</pre>
выводит:
<pre>
True
7
7
</pre>
Строковый метод index() возбуждает исключение, если подстрока не найдена, в то время как метод find() возвращаетзначение − 1−1.<br>
Все три механизма (оператор in, метод index() и метод find()) выполняют поиск подстроки путем прямого посимвольногосравнения. Это позволит выполнить работу во многих случаях, но иногда проблема оказывается сложнее. <br>
Что если вместофиксированной подстроки 123, мы хотим определить содержит ли строка text какие-либо три последовательных цифры, как вследующих строках:
<pre>
python 123 beegeek
python 342 stepik
789 beegeek
number 557 is awesome!
</pre> 
В такой ситуации, очевидно приведенные выше механизмы без дополнительной логики не сработают.<br>
Рассмотрим следующую задачу: пусть телефонный номер имеет шаблон ddd-ddd-dddd (три цифры дефис три цифры дефис четырецифры). <br>Требуется найти все телефонные номера в заданном тексте.<br>
Приведенный ниже код решает задачу(см файл Задача02.ру):
<pre>
  def is_phone_number(phone):
    groups = phone.split('-')
    if len(groups) != 3:
        return False
    chars = ''.join(groups)
    return all(c.isdigit() for c in chars)


def get_all_num(text):
    for c in range(len(text)):
        chunk = text[c:c + 12]
        if is_phone_number(chunk):
            yield chunk


txt = ('Привет всем, мой номер 919-654-8765, а еще у меня есть два дополнительных номера:543-780-0898 и 123-765-8907. '
       'Вот и все!')

print(list(get_all_num(txt)), end=' ')

Несмотря на то что код является рабочим и решает поставленную задачу, мы понимаем, что он не очень эффективный. Во-первых,с точки зрения расходуемой памяти, ведь нам приходится делать срезы по 1212 символов. 
Если исходная строка будет оченьбольшой, это может привести к проблемам нехватки памяти. 
Во-вторых, наш код жестко завязан на шаблон указанноготелефонного номера. 
При малейшем изменении шаблона или его расширении (например, символ +7 в начале) вся логика кодаломается. 
Другими словами, наш код открыт для изменения, но закрыт для расширения.  
</pre>
# Регулярные выражения.
Регулярные выражения (regular expression, regex, регулярка) – это мощный способ обработки текста, позволяющий находить в строках подстроки по сложным условиям.<br>
Чуть более формально, регулярное выражение — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных строк. Регулярное выражение состоит из обычных символов и специальных командных последовательностей. Например, \d задаёт любую цифру, а \d+ — задает любую последовательность из одной или более цифр.<br>
Работа с регулярными выражениями реализована во всех современных языках программирования. Однако существует несколько диалектов, поэтому функционал регулярных выражений может различаться от языка к языку.<br>

В некоторых языках программирования пользоваться регулярными выражениями очень удобно (например, Python), в некоторых — не слишком (например, C++).<br>
Регулярные выражения обычно применяют для:

- поиска подстрок в строке
- разделения строки на подстроки   
- замены части строки<br>
Приведем несколько примеров регулярных выражений:
![image](https://github.com/tvgVita69/RegularExpressions/assets/98489171/f039255e-76e8-494e-a05b-ff8ad556c8a0)

Регулярные выражения позволяют очень компактно описывать текстовые шаблоны.<br>
Например, указанный выше шаблон телефонного номера ddd-ddd-dddd (три цифры дефис три цифры дефис четыре цифры) можно описать регулярным выражением:
\d\d\d-\d\d\d-\d\d\d\d

или еще более компактной версией:
\d{3}-\d{3}-\d{4}

# Сырые строки и экранирование.
В языке Python некоторые символы нужно экранировать, чтобы они воспринимались правильно. К таким символам относятся:

- обратный слэш \
- одинарная кавычка '
- двойная кавычка "
- и многие другие

Приведенный ниже код:
<pre>
print('\\')
print('\'')
print("\"")
</pre>
выводит:
<pre>
 \
'
" 
</pre>
Экранированные последовательности — это последовательности, которые начинаются с символа \, за которым следует один или более символов (\\, \', \", \n, \t и т.д.).<br>
Чтобы написать правильно строку, в которой находятся два символа обратного слэша \\, оба символа надо экранировать, и в итоге получится строка вида \\\\. Вместо экранирования можно использовать сырые (raw) строки, и тогда каждый символ будет восприниматься так, как написан. Сырые строки отличаются от обычных тем, что при создании строки вначале пишется буква r.<br>
Приведенный ниже код:
<pre>
print(r'\\привет мир')
print(r'\\\\')
print(r'\n')
print(r'\t')  
</pre>
выводит:
<pre>
\\привет мир
\\\\
\n
\t
</pre>

Так как в регулярных выражениях часто используется символ обратного слэша \, то рекомендуется использовать сырые строки для описания регулярных выражений. Некоторые выражения правильно отработают и без них, но использование сырых строк для регулярных выражений это хороший тон.<br>

# Поиск заданного текста.

Для создания регулярных выражений необходимо использовать специальный синтаксис. Любая строка текста сама по себе является регулярным выражением. Например, Timur – это регулярное выражение. Поскольку это просто текст, он ничем не напоминает регулярное выражение, однако он им таки является. Регулярные выражения могут содержать простой текст и могут даже состоять из простого текста.
Регулярному выражению:
<pre>Timur</pre>
в тексте:
<pre>
Hello, my name is Timur. Please visit my website at https://stepik.org/org/pygen.  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
Hello, my name is <strong>Timur</strong>. Please visit my website at https://stepik.org/org/pygen.
</pre>
Используемое здесь регулярное выражение – буквальный текст, и оно находит вхождение Timur в исходном тексте. Регулярному выражению:
<pre>is</pre>
в тексте:
<pre>
Hello, my name is Timur. Please visit my website at https://stepik.org/org/pygen.    
</pre> 
соответствует (выделено жирным шрифтом):
<pre>
Hello, my name <strong>is</strong> Timur. Please v<strong>is</strong>it my website at https://stepik.org/org/pygen.   
</pre>
Обратите внимание на то, что было найдено два вхождения is.

Регулярные выражения сами по себе всегда ищут все вхождения. Модуль <strong>re</strong>, который будет изучен нами чуть позже, включает разные функции, и те, которые ищут только первое вхождение, и те которые возвращают список всех вхождений, соответсвующих регулярному выражению.<br>
Регулярные выражения являются регистрозависимыми, то есть регулярному выражению Timur не будет соответствовать строка timur.

# Поиск любого символа.
С помощью регулярных выражений можно искать не только известный заранее (статический) текст, но и текст в котором есть неизвестные символы. Чтобы найти соответствие некоторому шаблону, в регулярных выражениях используются специальные символы (или наборы символов), которые называются метасимволами. Символ точка . соответствует одному любому символу.
Регулярному выражению:
<pre>
sales  
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre>
соответствует (выделено жирным шрифтом):
 <pre>
<strong>sales1.csv</strong> 
orders3.csv 
<strong>sales2.csv</strong> 
<strong>sales3.csv</strong> 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre>
Регулярное выражение sales., позволяет найти все имена файлов, содержащие подстроку sales, за которой следует еще один произвольный символ. Ровно три файла из девяти соответствуют такому шаблону.
Обратите внимание на то, что регулярные выражения сопоставляют шаблоны строкам. Эти шаблоны не всегда будут совпадать со всей строкой, а только с теми символами, которые соответствуют шаблону, даже если они являются только частью строки.
Таким образом, специальный символ . соответствует любому символу – символу алфавита, цифре и даже самому символу точки . Регулярному выражению:
<pre>
sales.  
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv    
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv    
</pre>
Этот пример содержит один дополнительный файл sales.csv. Файл был найден с помощью регулярного выражения sales., поскольку специальный символ . находит любой символ.
В регулярном выражении можно использовать несколько символов ., либо вместе (регулярное выражение .. будет соответствовать любым двум символам друг рядом с другом), либо в различных местах.
Регулярному выражению:
<pre>
 .a. 
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv   
</pre>
соответствует (выделено жирным шрифтом):
 <pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv    
</pre>
Если мы хотим найти все файлы только для Северной Америки (na) и Южной Америки (sa) независимо от того, какая цифра следует после этих сокращений, то нам нужно немного изменить регулярное выражение. Необходимо регулярное выражение .a. за которым следует точка.
Регулярному выражению:
<pre>
 .a.. 
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv    
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv    
</pre>
Несложно заметить, что регулярное выражение .a.. работает нисколько не лучше, чем .a., поскольку добавленная точка соответствует любому символу.<br>
# Поиск символа точки.
Точка . имеет специальное значение в регулярных выражениях. Если в регулярном выражении нужен сам символ точки ., то ее необходимо экранировать. Для этого необходимо предварить точку символом обратного слэша \.

В регулярных выражениях точка . соответствует любому символу, а обратный слэш с точкой \. соответствует только самому символу точки ..
Регулярному выражению:
<pre>
.a.\.csv
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre>
Первый символ . в регулярном выражении .a.\.csv соответствует символу n (в первых двух вхождениях) или символу s (в третьем вхождении). Второй символ . соответствует символу 1 (в первом и третьем вхождениях) или символу 2 (во втором вхождении).<br>
Последовательность символов \. соответствует точке ., отделяющей имя файла от расширения, а последовательность символов csv соответствует самой себе.<br>
  Если в регулярном выражении нужен символ \, то его также нужно экранировать \\.<br>
# Поиск цифр.
Как уже было сказано, метасимволы – это символы, которые имеют специальное значение в регулярных выражениях. Для поиска любой цифры от 0 до 9 используется метасимвол \d.<br>
Регулярному выражению:
<pre>
..\d
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre>
Для поиска любого нецифрового символа используется метасимвол \D. Регулярному выражению:
<pre>
e\D
</pre>
в тексте:
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre> 
соответствует (выделено жирным шрифтом):
<pre>
sales1.csv 
orders3.csv 
sales2.csv 
sales3.csv 
apac1.csv
europe2.csv 
na1.csv
na2.csv  
</pre>
# Поиск пробельных символов.
Для поиска пробельного символа (пробел, табуляция, конец строки) используется метасимвол \s. Регулярному выражению:
<pre>
.\s.
</pre>
в тексте:
<pre>
привет, наконец начали изучать регулярные выражения.  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
привет, наконец начали изучать регулярные выражения.  
</pre>
Для поиска любого непробельного символа используется метасимвол \S. Регулярному выражению:
<pre>
к\S\S
</pre>
в тексте:
<pre>
Математик, учитель, написание нового курса скорррро.  
</pre>
соответствует (выделено жирным шрифтом):
<pre>
Математик, учитель, написание нового курса скорррро.
</pre>
Поиск алфавитно-цифровых символов
Есть еще один часто используемый набор – буквы (в верхнем и нижнем регистре), цифры и символ подчеркивания. Для поиска таких символов используется метасимвол \w.
Регулярному выражению:
<pre>
\w\w\w\w
</pre>
в тексте:
<pre>
xy_ 
1234
geek
-xy- 
Code 
a1b2 
</pre>
соответствует (выделено жирным шрифтом):
<pre>
xy_ 
1234
geek
-xy- 
Code 
a1b2 
</pre>
Для поиска символов не являющийся буквой, цифрой и подчёркиванием используется метасимвол \W. Регулярному выражению:
<pre>
\w\W\W\w
</pre>  
в тексте:
<pre>
x!?y
a..b 
geek 
1+-2
1234
--
x y
</pre>
соответствует (выделено жирным шрифтом):
<pre>
x!?y
a..b 
geek 
1+-2
1234
--
x y 
</pre>

## Примечания.
Примечание 1. Так же, как и в Python, в регулярных выражениях выражение \n соответствует концу строки, а \t — табуляции.

Примечание 2. Регулярные выражения — как полицейский-регулировщик. Когда учишься, всё просто и элементарно, а когда встречаешь в реальности, понимаешь, что всё забыл 😂.

Примечание 3. Как правило, в регулярных выражениях точке . соответствует любой символ. Однако в большинстве реализаций регулярных выражений точке . соответствует любой символ, кроме символа новой строки (\n).

Примечание 4. Сайт для отладки регулярных выражений доступен по [ссылке](https://regex101.com/) (не забудьте поставить галочку Python в разделе FLAVOR слева).

Примечание 5. Разные сложные трюки и тонкости работы с регулярными выражениями доступны по [ссылке](https://www.rexegg.com/). 

Примечание 6. Очень подробный и обстоятельный материал по регулярным выражениям доступен по [ссылке](https://www.regular-expressions.info/).





















